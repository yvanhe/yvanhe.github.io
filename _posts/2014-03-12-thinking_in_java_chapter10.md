---
layout: post
title: Java编程思想 - 第十章、内部类
categories: Java
tags: Java编程思想
---

###本章主题

这一章讲述的是内部类，以前觉得这东西花费一个小节简单介绍一下如何使用就好，但《Head First Java》和《Thinking In Java》都把内部类作为单独的一章来讲。Sun公司花费了如此苦心来增加这项基本的语言特性。但是我却没有认识到内部类的重要性。所以看完后，需要认真总结一下：

1. **为什么需要内部类？**
2. **什么情况下该使用内部类？**

填坑ing...在10.8节中道出了内部类的本质作用【同时也解答上章最后的问题】：

> 内部类继承自某个类或实现某个接口，内部类的代码操作创建它的外部类的对象。从某种意义上来说，内部类可以作为外部类和外部的窗口。使用内部类最吸引人的原因是：**每个内部类都能独立地继承自一个（接口的）实现，所以无论外部类是否已经继承了某个（接口的）实现，对于内部类来说都没有影响。**从另一个角度来看，内部类通过继承多个**非接口（类或者抽象类）**，使多重继承的方案更加完整可行。因为是单继承，不可能有多个extends。而非接口只能通过extends实现，所以内部类对这些情况就有了作用。

我们知道，C++中有多重继承的概念，但随之而来的就是菱形继承的噩梦。JAVA设计者避免了这个做法，但多重继承也是一个使用频繁的功能，于是JAVA运用单继承+接口+内部类的方向完成了相同的功能。虽然稍微麻烦点，但是也一定程度避免了C++的问题。算是有得也有失吧。

然后这一章看的不细致，因为里面很大一部分是有点偏的知识，我打算先把精华看一下，等我下遍复习的时候从整体上来把握细节。额，现在看的确实有点晕乎了。。。

###1. 什么是内部类

顾名思义，内部类就是在类内部定义的类，但是它有一个天然的属性特别重要：

> 当生成一个内部类的对象时，此对象与生成它的外部对象之间就有了联系，所以它能访问其外部类的所有成员，而不需要任何特殊条件。

我们一想，这敢情好啊。内部类和外部类之间完全没有隔阂，数据通信无障碍（private都不是个事）。但它是怎么实现的呢？
> 当某个外部类的对象创建了一个内部类对象时，此内部类对象必定会秘密地捕获一个指向那个外部类的引用。然后，在你访问外部类的成员时，就是用那个引用来访问外部类的成员。而且，这都是编译器帮我们搞定的。

###2. 匿名内部类

多线程时候用到过，Runnable相当于一个任务，Thread相当于一个工人。那么我们把这个任务给工人后，告诉它start()就可以执行了。这时候，交付任务就是通过匿名内部类实现的，举个例子：

{% highlight java linenos %}
public void testNoNameInnerClass() {
	    executor.execute(
	        new Runnable() {
	    	    public void run() {
	    		    //do something
	    	    }
	        }
	    );
	}
{% endhighlight java %}

###3. 工厂设计模式

写了一篇文章，还是写点代码能清楚点。[工厂模式](http://www.thinkingbar.com/2014/03/14/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/)

###4. 嵌套类

如果不想让内部类和外部类有联系，我们可以将内部类定义为static，而这就是嵌套类。其实也很容易理解，不带static的话，内部类对象会隐式的保存一个外部类的引用，指向创建它的外部类；而声明为static之后，因为它是外部类的属性，就没有隐式的引用。所以你创建内部类的时候就不需要外部类的羁绊了。
